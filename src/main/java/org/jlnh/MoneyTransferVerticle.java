package org.jlnh;

import io.vertx.config.ConfigRetriever;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.sql.SQLOptions;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jlnh.model.Transaction;
import org.jlnh.service.TransactionService;

public class MoneyTransferVerticle extends AbstractVerticle {

    private JDBCClient jdbcClient;

    private TransactionService transactionService = new TransactionService();

    private static final Logger LOGGER = LogManager.getLogger(MoneyTransferVerticle.class);


    @Override
    public void start() {
        this.createHttpServer();
    }

    private void createHttpServer() {
        Router router = Router.router(vertx);
        router.route().handler(BodyHandler.create());

        router.post("/api/transfer").handler(this::transferMoney);

        ConfigRetriever configRetriever = ConfigRetriever.create(vertx);
        ConfigRetriever.getConfigAsFuture(configRetriever)
                .compose(config -> {
                    jdbcClient = JDBCClient.createShared(vertx, config, "test");

                    return connect(jdbcClient) //
                            .compose(sqlConnection -> { //
                                Future<Void> future = Future.future();
                                createTablesIfNeeded(sqlConnection) //
                                        .setHandler(event -> { //
                                            sqlConnection.close();
                                            future.handle(event.mapEmpty());
                                        });
                            return null; //TODO complete
                            });
                });

        //router.get("/api/transfer").handler(this::getAll);
        //router.get("/api/transfer/:id").handler(this::getOne);

        vertx.createHttpServer().requestHandler(router).listen(8080);
    }

    public Future<SQLConnection> connect(JDBCClient jdbcClient) {
        Future<SQLConnection> future = Future.future();
        jdbcClient.getConnection(asyncResult -> //
                future.handle(asyncResult.map(connection -> //
                        connection.setOptions(new SQLOptions().setAutoGeneratedKeys(true)))));
        return future;
    }

    /**
     *
     * @param connection
     * @return
     */
    private Future<SQLConnection> createTablesIfNeeded(SQLConnection connection) {
        Future<SQLConnection> future = Future.future();
        vertx.fileSystem().readFile("V__01_Create.sql", ar -> {
            if (ar.failed()) {
                future.fail(ar.cause());
            } else {
                connection.execute(ar.result().toString(),
                        ar2 -> future.handle(ar2.map(connection))
                );
            }
        });
        return future;
    }

    private void transferMoney(RoutingContext routingContext) {
        Transaction theTransaction = routingContext.getBodyAsJson().mapTo(Transaction.class);
        LOGGER.error(theTransaction.toString());

        transactionService.transferMoney(theTransaction.getFrom(), theTransaction.getTo(), theTransaction.getAmount());

        routingContext.response() //
                .setStatusCode(201) //
                .putHeader("content-type", "application/json; charset=utf-8") //
                .end("Transaction done!");
    }

    /*Review when whe have a db
    private void getAll(RoutingContext routingContext) {
        routingContext.response() //
                .setStatusCode(200) //
                .putHeader("content-type", "application/json; charset=utf-8") //
                .end(Json.encodePrettily(transactions));
    }
     */
}