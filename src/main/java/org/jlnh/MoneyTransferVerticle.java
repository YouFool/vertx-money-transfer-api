package org.jlnh;

import io.vertx.config.ConfigRetriever;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.sql.SQLOptions;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jlnh.model.Account;
import org.jlnh.model.Transaction;

import java.math.BigDecimal;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import static org.jlnh.util.ActionHelper.handleTransfer;
import static org.jlnh.util.ActionHelper.ok;

/**
 * Verticle responsible for the money transfer API.
 *
 * @author Jo√£o Heckmann
 */
public class MoneyTransferVerticle extends AbstractVerticle {

    private JDBCClient jdbcClient;

    private static final Logger LOGGER = LogManager.getLogger(MoneyTransferVerticle.class);


    @Override
    public void start(Future<Void> startFuture) {
        Router router = Router.router(vertx);
        router.route().handler(BodyHandler.create());

        router.post("/api/transfer").handler(this::transfer);

        router.get("/api/accounts").handler(this::getAllAccounts);
        router.get("/api/accounts/:id").handler(this::getAccount);

        ConfigRetriever configRetriever = ConfigRetriever.create(vertx);
        ConfigRetriever.getConfigAsFuture(configRetriever)
                .compose(config -> {
                    jdbcClient = JDBCClient.createShared(vertx, config, "test");

                    return connect() //
                            .compose(sqlConnection -> { //
                                Future<Void> future = Future.future();
                                createTablesIfNeeded(sqlConnection) //
                                        .setHandler(event -> { //
                                            sqlConnection.close();
                                            future.handle(event.mapEmpty());
                                        });
                                return future;
                            }).compose(v -> createHttpServer(config, router));
                }).setHandler(startFuture);
    }

    /**
     * Reads the config file and starts the HTTP server asynchronously.
     *
     * @param config {@link JsonObject} with the application configuration
     * @param router {@link Router} the server router
     * @return Future empty result
     */
    private Future<Void> createHttpServer(JsonObject config, Router router) {
        Future<Void> future = Future.future();
        vertx.createHttpServer() //
            .requestHandler(router) //
                .listen(config.getInteger("HTTP_PORT", 8080), res -> future.handle(res.mapEmpty()));
        return future;
    }

    /**
     * Fetches a database connection asynchronously.
     *
     * @return a future {@link SQLConnection} connection
     */
    private Future<SQLConnection> connect() {
        Future<SQLConnection> future = Future.future();
        jdbcClient.getConnection(asyncResult -> //
                future.handle(asyncResult.map(connection -> //
                        connection.setOptions(new SQLOptions().setAutoGeneratedKeys(true)))));
        return future;
    }

    /**
     * Creates the database tables and accounts.
     *
     * @param connection {@link SQLConnection} database connection
     * @return the connection itself
     */
    private Future<SQLConnection> createTablesIfNeeded(SQLConnection connection) {
        Future<SQLConnection> future = Future.future();
        vertx.fileSystem().readFile("scripts/V__01_Create.sql", readFile -> {
            if (readFile.failed()) {
                future.fail(readFile.cause());
            } else {
                connection.execute(readFile.result().toString(), //
                        executeStatement -> future.handle(executeStatement.map(connection))
                );
            }
        });
        return future;
    }

    /**
     * Transfer money between two accounts with a given {@link Transaction} input.
     *
     * @param routingContext request context
     */
    private void transfer(RoutingContext routingContext) {
        Transaction theTransaction = routingContext.getBodyAsJson().mapTo(Transaction.class);
        LOGGER.info("Transaction incoming: ".concat(theTransaction.toString()));

        connect() //
                .compose(sqlConnection -> this.doTransfer(sqlConnection, theTransaction))
                .setHandler(handleTransfer(routingContext, theTransaction));
    }

    /**
     * With the given {@link Transaction} input, finds the two accounts balance and executes the transfer.
     *
     * @param sqlConnection the database connection
     * @param theTransaction transaction to be executed
     * @return future transaction which might be completed or refused
     */
    private Future<Transaction> doTransfer(SQLConnection sqlConnection, Transaction theTransaction) {
        Future<Transaction> transactionFuture = Future.future();

        this.findAccount(theTransaction.getFrom().getId().toString(), sqlConnection, false)
                .compose(fromAccount -> {
                    Future<Account> toAccountFuture = Future.future();

                    this.findAccount(theTransaction.getTo().getId().toString(), sqlConnection, false)
                            .compose(toAccount -> {
                                this.transferMoney(fromAccount, toAccount, theTransaction.getAmount(), sqlConnection)
                                        .setHandler(event -> {
                                            if (event.failed()) {
                                                transactionFuture.fail(event.cause());
                                            } else {
                                                transactionFuture.complete(event.result());
                                            }
                                        });
                            return transactionFuture;
                            });
                    return toAccountFuture.mapEmpty();
                });

        return transactionFuture;
    }

    /**
     * Get all accounts.
     *
     * @param routingContext request context
     */
    private void getAllAccounts(RoutingContext routingContext) {
        connect()
                .compose(this::findAllAccounts) //
                .setHandler(ok(routingContext));
    }

    /**
     * Finds all accounts and maps the {@link io.vertx.ext.sql.ResultSet ResultSet} into {@link Account accounts}.
     *
     * @param connection database connection
     * @return all the accounts
     */
    private Future<List<Account>> findAllAccounts(SQLConnection connection) {
        Future<List<Account>> future = Future.future();
        connection.query("SELECT * FROM account", result -> {
                    connection.close();
                    future.handle(
                            result.map(resultSet -> resultSet.getRows()
                                    .stream()
                                    .map(Account::new)
                                    .collect(Collectors.toList()))
                    );
                }
        );
        return future;
    }

    /**
     * Get a single account by the account {@link UUID id}.
     *
     * @param routingContext request context
     */
    private void getAccount(RoutingContext routingContext) {
        String id = routingContext.pathParam("id");
        connect() //
                .compose(sqlConnection -> this.findAccount(id, sqlConnection, true)) //
                .setHandler(ok(routingContext));
    }

    /**
     * Finds a single account by it's {@link UUID id} and maps the result into a {@link Account account}.
     *
     * @param sqlConnection database connection
     * @param id account id
     * @param closeConnection close or not database connection
     * @return the account found
     */
    private Future<Account> findAccount(String id, SQLConnection sqlConnection, boolean closeConnection) {
        Future<Account> future = Future.future();
        String sql = "SELECT * FROM account WHERE id = ?";
        sqlConnection.queryWithParams(sql, new JsonArray().add(id), result -> {
            if (closeConnection) {
                sqlConnection.close();
            }
            future.handle(result.map(
                    resultSet -> new Account(resultSet.getRows().get(0)))
            );
        });

        return future;
    }

    /**
     * Transfers a given amount from the sender account to the receiver account.
     *
     * @param sender account that is sending the amount
     * @param receiver account that is receiving the amount
     * @param amount the amount itself
     * @param sqlConnection database connection
     * @throws IllegalStateException if the amount is greater than sender's account balance
     */
    private Future<Transaction> transferMoney(Account sender, Account receiver, BigDecimal amount, SQLConnection sqlConnection) {
        Future<Transaction> future = Future.future();

        LOGGER.info("Transferring: ".concat(amount.toString()));
        LOGGER.info("From: ".concat(sender.toString()));
        LOGGER.info("To: ".concat(receiver.toString()));

        BigDecimal senderBalance = sender.getBalance();
        if (senderBalance.compareTo(amount) < 0) {
            LOGGER.warn("Sender: ".concat(sender.toString()).concat(" does not have enough money!"));
            future.fail(new IllegalStateException("Could not transfer money!"));
        } else {
            JsonArray createNewTransactionParams = new JsonArray()
                    .add(UUID.randomUUID().toString())
                    .add(sender.getId().toString())
                    .add(receiver.getId().toString())
                    .add(amount.doubleValue());
            sqlConnection.updateWithParams("INSERT INTO transaction VALUES(?, ?, ?, ?)", createNewTransactionParams, ar -> {
                sender.setBalance(senderBalance.subtract(amount));
                JsonArray params2 = new JsonArray().add(sender.getBalance().doubleValue()).add(sender.getId().toString());
                sqlConnection.updateWithParams("UPDATE account SET balance = ? WHERE id = ?", params2, event ->  {

                    receiver.setBalance(receiver.getBalance().add(amount));
                    JsonArray params3 = new JsonArray().add(receiver.getBalance().doubleValue()).add(receiver.getId().toString());
                    sqlConnection.updateWithParams("UPDATE account SET balance = ? WHERE id = ?", params3, AsyncResult::mapEmpty);
                });
            });
            future.complete();
        }
        return future;
    }

}